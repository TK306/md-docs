# 内部設計仕様書

## 目次

- **アーキテクチャ概要**: 層構造と責務の切り分け
- **モジュール責務**: `src/domain`, `src/adapters`, `src/interfaces`, `src/usecase` の役割
- **データモデル詳細**: `Document` / `DocNode` 型、各フィールド、`Table.as_dict` の仕様
- **主要クラス・関数のシグネチャ**: 具体的な型と返り値、例外
- **パース/レンダリングのフロー**: シーケンス（ステップ毎の処理）
- **アルゴリズムと実装ノート**: 正規表現、表のパース、フロントマター処理
- **エラー処理と例外設計**: 例外タイプとハンドリング方針
- **拡張性・入れ替えポイント**: 新しいノード追加やストレージ交換の手順
- **テスト戦略**: 単体テストの粒度と代表的なテスト項目
- **変更履歴**

---

## アーキテクチャ概要

本プロジェクトはクリーンアーキテクチャ（Ports & Adapters / Onion / Hexagonal の考え方）を採用します。依存関係の基本ルールは「外側は内側に依存するが、内側は外側に依存しない（Dependency Rule）」です。これによりドメイン（ビジネスロジック）を外部技術やフレームワークから独立させ、保守性・テスト容易性・差し替え性を高めます。

主なレイヤ（内側 → 外側）:

- **Entities / Domain（最内側）**: `src/domain` — `Document` / `DocNode` と `DocConvertible` 等の純粋なドメインモデル。副作用を持ちません。
- **Use Cases / Application**: `src/usecase` — ドメインを組み合わせて具体的なユースケースを実行するロジック（例: `ConvertFileUsecase`）。外部への依存はポート（抽象）経由で行います。
- **Interface Adapters / Ports**: `src/interfaces`（ポート定義）と `src/adapters`（アダプタ実装）。Usecase が依存する抽象（`DocumentParser`, `DocumentRenderer`, `Storage`）を定義し、アダプタがそれを実装します。
- **Frameworks & Drivers（外側）**: `main.py`, `sample_main.py`, `mdformat`、実際のファイルシステムなど。ここでアダプタを組み立てて Usecase に注入します。

設計上の方針: ドメインは完全に副作用を排し、Usecase はドメインに依存するが外側の具象には依存しない。外側（アダプタ）は `src/interfaces` の抽象を実装して内側へ接続します。外部ライブラリ（例: `mdformat`）はアダプタ層でラップして差し替え可能にすることを推奨します。

### クリーンアーキテクチャ採用方針

本プロジェクトはクリーンアーキテクチャ（依存性の向き：外側→内側）への移行を推奨します。現状のコードベースは既にドメインの純粋性や `Protocol` による抽象化を備えており、移行のコストは低いと見込まれます。導入の目的は、ビジネスルール（ドメイン）を外部技術・フレームワークから独立させ、テスト容易性と差し替え性を高めることです。

移行の方針要点:

- **内側（Entities / Domain）**: `src/domain` に保持し副作用を排除する。ここに依存関係は集中する。
- **アプリケーション層（Usecase）**: `src/usecase` に配置し、ドメインを使ってユースケースを実装する。外部依存は `src/interfaces/protocols.py` の抽象を通じて扱う。
- **インターフェイス（Ports）**: `src/interfaces/protocols.py` を内側のポートとして扱い、Usecase がこれらの抽象に依存する。
- **アダプタ（Adapters / Gateways）**: `src/adapters` に配置し、`protocols` の実装を提供する。具体実装はここに閉じる。

この設計により、`usecase` 層は `adapters` に直接依存することなく、テスト時はモックやスタブを注入して外部 IO に依存しない単体テストが可能になります。

## モジュール責務

- `src/domain/doc_ir.py`:
	- `DocNode` 系（`Heading`, `Paragraph`, `BulletList`, `NumberedList`, `Table`, `Image`）と `Document` を定義。
	- `Table.as_dict` を持ち、表→辞書変換のロジックとバリデーションを提供。
- `src/domain/markdown_parser.py`:
	- `DocumentInspector`（旧 `DocParser`）ユーティリティを提供。`find_heading`, `first_heading`, `tables`, `bullet_list_after` を備える。
- `src/domain/doc_cursor.py`:
	- `NodeCursor`（旧 `DocCursor`）を提供。`DocNode` 列を順次巡回する軽量カーソルで、`peek`/`next`/`expect`/`take_while`/`collect_paragraph_text`/`parse_table_as_dict` などの小さな抽出 API を持つ。
	- `MarkdownParseError` を定義。
- `src/adapters/markdown_parser.py`:
	- 文字列から `Document` を生成する具体パーサ。フロントマター検出、行走査による構文解析を行う。
- `src/adapters/markdown_renderer.py`:
	- `Document` から Markdown 文字列を生成する。レンダリングはノード毎に分岐して処理する。
- `src/adapters/markdown_adapter.py`:
	- `DocumentParser` / `DocumentRenderer` プロトコルに適合させるアダプタを提供。`MarkdownRendererAdapter` は `mdformat` を利用して出力を整形する。
- `src/adapters/file_storage.py`:
	- `Storage` プロトコルに従うファイル読み書き実装。

## データモデル詳細

- `Document`
	- `front_matter: dict[str,str]` — HTML コメント形式で取り出したキー/バリューの辞書
	- `nodes: list[DocNode]` — ドキュメント本文を示すノード列
- `Table`
	- `headers: list[str]`
	- `rows: list[list[str]]`
	- `as_dict(ignore_extra_columns: bool = False) -> dict[str,str]`:
		- 実装は行を順にスキャンし、`row[0]` をキー、`row[1]` を値として格納
		- `len(row) < 2` の場合 `ValueError`
		- `len(row) > 2` の場合は `ignore_extra_columns` が False なら `ValueError`、True なら余分な列を無視
		- 重複キー検出で `ValueError`

	- ヘッダと行の列数整合ルール（追記）:
		- 仕様としてはテーブルのヘッダセル数と各データ行のセル数が一致することを推奨します。
		- 現状の実装はヘッダ長と行長の一致を厳密に強制していません。必要に応じて `Table` に行長検証メソッドを追加し、厳格モードで不整合時に `ValueError` を投げることを検討してください。

## 主要クラス・関数のシグネチャ

- `class DocConvertible(ABC)` (`src/domain/doc_convertible.py`)
	- `def to_nodes(self) -> list[DocNode]` — インスタンスをノード列に変換
	- `@classmethod def from_nodes(cls, nodes: list[DocNode], front_matter: dict[str,str] | None = None) -> T`
		- 既定挙動: 具象クラスが `from_cursor(cls, cur)` を実装している場合、`from_nodes` の既定実装は `NodeCursor(nodes, front_matter)` を作成して `from_cursor` を呼び出す。これにより具象クラスは `NodeCursor` を使って簡潔にノード抽出処理を実装できる。
		- 互換性: 旧来の `from_nodes` を直接オーバーライドする実装はそのまま動作する。
	- 設計制約: I/O や文字列整形は行わない。変換ロジックとバリデーションは具象クラス側で行う。
	- フロントマター出力フック: `DocConvertible` は `to_front_matter(self) -> dict[str,str]` を提供することが推奨されます。既定実装は空辞書を返します。`ConvertFileUsecase.save_model_to_path` はこのフロントマターを利用して `Document(front_matter=...)` を作成します。

- `class DocumentInspector` (`src/domain/markdown_parser.py`)
	- `def find_heading(self, level: int) -> list[Heading]`
	- `def first_heading(self, level: int) -> Heading | None`
	- `def tables(self) -> list[Table]`
	- `def bullet_list_after(self, heading_text: str, level: int) -> list[str]`
- `def parse_markdown(markdown_text: str) -> Document` (`src/adapters/markdown_parser.py`)
	- 主要処理: フロントマター抽出 → 行走査で各ノードを構築 → `Document(front_matter, nodes)` を返す
	- 例外: `MarkdownParseError`
- `def document_to_markdown(doc: Document) -> str` (`src/adapters/markdown_renderer.py`)
	- ノード毎のレンダリングをまとめて文字列を返す。整形は行わない（`MarkdownRendererAdapter` が `mdformat` を呼ぶ）。

## パース / レンダリングのフロー（シーケンス）

1. 呼び出し側が `FileStorage.read(path)` で Markdown 文字列を取得
2. `MarkdownParserAdapter.parse(text)` を呼び `Document` を得る
3. 必要に応じ `DocumentInspector(nodes)` を生成し、`tables()` や `find_heading()` を使ってノードを検索
4. ユーザが実装した `DocConvertible.from_nodes(nodes, front_matter)` または `from_cursor(cur)` を使ってアプリケーションモデルを生成
	- パーサは `Document(front_matter, nodes)` を返すため、`front_matter` を `from_nodes` に渡すことでモデル生成に利用できる。
	- 具象クラスが `from_cursor` を実装している場合、`from_nodes` の既定実装が `NodeCursor(nodes, front_matter)` を生成して `from_cursor` を呼び出すため、具象は `NodeCursor` を直接扱うことで実装が簡潔になる。
5. 逆変換は `to_nodes()` でノード列を得て `MarkdownRendererAdapter.render(doc)` に渡す
6. `FileStorage.write(path, content)` でファイルに保存

## アルゴリズムと実装ノート

- **フロントマター検出**: ファイル先頭で `<!--` を検出し、`-->` までの行を `key: value` で分割して辞書化。空行はスキップ。
- **見出し検出**: 行頭の `#` の数でレベルを決定し、その後のテキストを見出し文として取得。空の見出しは `MarkdownParseError` を投げる。
- **表のパース**:
	- ヘッダ行は `|` 区切りでセルを抽出（先頭・末尾の `|` を除去して `headers` とする）
	- 次行が `|---|` のようなセパレータ行（正規表現 `^\|[\s\-\|]*\|$`）であればスキップ
	- 以降 `|` で始まる行を `rows` として収集
- **表→辞書 (`Table.as_dict`) の注意**: 行ごとにセル数チェックを行い、例外を明示的に投げることで呼び出し側で明確に扱えるようにしている。

## エラー処理と例外設計

- `MarkdownParseError`: パース時の構文エラー。メッセージに行番号や原因を含める。
- `ValueError`: 内部データ検証（例: `Table.as_dict` の列数・重複キー）に使用。
- 例外ハンドリング方針: アダプタ/ユースケース層で捕捉してユーザ向けメッセージに変換、ログ記録を行う。

## 拡張性・入れ替えポイント

- 新しいノードを追加する場合:
	- `src/domain/doc_ir.py` にノードを追加し、`adapters` の `parse_markdown` と `render_node`（または `document_to_markdown`）を拡張する。
- ストレージの入れ替え:
	- `Storage` プロトコルを実装して `FileStorage` を差し替えればよい。
- カスタムフォーマット/拡張 Markdown を導入する場合:
	- `src/adapters/markdown_parser.py` のパーサをプラグイン化して差し替える設計を推奨。

## テスト戦略

本プロジェクトでは外部設計で定義した仕様（`docs/02_外部設計仕様書.md` の `SPEC-...`）と実装テストを一対一で紐付けします。各仕様項目は専用のテスト（ファイル+関数）で検証し、仕様の回帰を容易に追跡できるようにします。

方針:

- **単一責務のテスト**: 各テストは 1 つの `SPEC-` ID に対応し、その仕様の期待動作とエラー条件を検証する。
- **外部依存の分離**: Usecase 層のテストは `protocols` をモック/スタブして外部 I/O に依存しない単体テストを行う。
- **仕様トレーサビリティ**: ドキュメントに SPEC ID とテスト名を明記し、仕様変更時にどのテストを更新すべきか一目で分かるようにする。

追加ルール:

- 新しい外部仕様を追加する際は必ず `SPEC-` プレフィックスで ID を割り振り、対応するテストを `tests/spec_tests/` に作成すること。
- 既存テスト（リポジトリ内）とは別に、仕様トレーサビリティ用の `tests/spec_tests/` を優先して回帰検証を実行する運用を推奨します。


## 変更履歴

- 2025-12-27: 初版（実装を参照して作成）

## ファイル・モジュールマッピング

- `src/domain`:
	- `doc_ir.py`: `Document` と `DocNode` 定義、`Table.as_dict` の実装
	- `doc_convertible.py`: `DocConvertible` 抽象クラス
	- `markdown_parser.py`: `DocumentInspector`（旧 `DocParser`）ユーティリティ（ノード検索など）
	- `doc_cursor.py`: `NodeCursor`（旧 `DocCursor`） — `DocNode` 列を逐次巡回するユーティリティで、具象の `from_cursor` 実装を容易にする。
- `src/interfaces`:
	- `protocols.py`: `DocumentParser`, `DocumentRenderer`, `Storage` の抽象
- `src/adapters`:
	- `markdown_parser.py`: 文字列→`Document` 実装
	- `markdown_renderer.py`: `Document`→文字列 実装
	- `markdown_adapter.py`: `DocumentParser` / `DocumentRenderer` アダプタ（`mdformat` 整形）
	- `file_storage.py`: `Storage` のファイル実装
- `src/usecase`:
	- `convert_usecase.py`: `ConvertFileUsecase`（ユースケースの骨組み）

## Usecase 詳細: `ConvertFileUsecase`

- 目的: アダプタ（parser/renderer/storage）を注入し、ファイル ↔ ドメインオブジェクト の変換を提供する。
- 主要メソッド:
	- `__init__(self, parser: DocumentParser, renderer: DocumentRenderer, storage: Storage)`
	- `load_model_from_path(self, path: Path, model_cls: Type[DocConvertible]) -> DocConvertible`
		- 動作: `storage.read(path)` → `parser.parse(text)` → `model_cls.from_nodes(doc.nodes, front_matter=doc.front_matter)`
		- 例外: パース失敗は `MarkdownParseError`、モデル変換失敗は `ValueError` を伝搬
	- `save_model_to_path(self, model: DocConvertible, path: Path) -> None`
		- 動作: `model.to_nodes()` を呼びノード列を取得。モデルが `to_front_matter()` を実装していればその戻り値を用いて `Document(front_matter=...)` を作成し、`renderer.render(doc)` の結果を `storage.write(path, text)` で保存する（未実装なら空辞書を用いる）。

## DI / 実行エントリの例

- `sample_main.py`（リポジトリ内）を参照。アダプタ実装を生成して Usecase に注入するサンプルコードを提供している。

## テストマッピング

- ドメイン層のテスト:
	- `tests/test_domain_docparser.py` — `DocumentInspector` の振る舞い
	- `tests/test_table_as_dict.py` — `Table.as_dict` の境界テスト
- ユースケース/統合テスト:
	- `tests/test_convert_usecase.py` — `ConvertFileUsecase` の単体テスト（in-memory ストレージ / ダミー実装）

## クリーンアーキテクチャ移行チェックリスト（実務向け）

1. `src/usecase` に代表的ユースケースを実装し、adapter は `protocols` の実装のみを提供する。
2. ユースケースのユニットテストは `protocols` をモックして実行できることを確認する。
3. ドメイン層から `adapters` を直接参照する箇所がないかをコードレビューでチェックする。
4. 重要な外部依存（例: `mdformat`）は `Formatter` のようなポートを定義してラップすることを検討する。


