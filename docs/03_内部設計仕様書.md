# 内部設計仕様書

## 目次

- **アーキテクチャ概要**: 層構造と責務の切り分け
- **モジュール責務**: `src/domain`, `src/adapters`, `src/interfaces`, `src/usecase` の役割
- **データモデル詳細**: `Document` / `DocNode` 型、各フィールド、`Table.as_dict` の仕様
- **主要クラス・関数のシグネチャ**: 具体的な型と返り値、例外
- **パース/レンダリングのフロー**: シーケンス（ステップ毎の処理）
- **アルゴリズムと実装ノート**: 正規表現、表のパース、フロントマター処理
- **エラー処理と例外設計**: 例外タイプとハンドリング方針
- **拡張性・入れ替えポイント**: 新しいノード追加やストレージ交換の手順
- **テスト戦略**: 単体テストの粒度と代表的なテスト項目
- **変更履歴**

---

## アーキテクチャ概要

本プロジェクトはクリーンアーキテクチャ（Ports & Adapters / Onion / Hexagonal の考え方）を採用します。依存関係の基本ルールは「外側は内側に依存するが、内側は外側に依存しない（Dependency Rule）」です。これによりドメイン（ビジネスロジック）を外部技術やフレームワークから独立させ、保守性・テスト容易性・差し替え性を高めます。

主なレイヤ（内側 → 外側）:

- **Entities / Domain（最内側）**: `src/domain` — `Document` / `DocNode` と `DocConvertible` 等の純粋なドメインモデル。副作用を持ちません。
- **Use Cases / Application**: `src/usecase` — ドメインを組み合わせて具体的なユースケースを実行するロジック（例: `ConvertFileUsecase`, `dump_eval_item`/`load_eval_item`）。外部への依存はポート（抽象）経由で行います。
- **Interface Adapters / Ports**: `src/interfaces`（ポート定義）と `src/adapters`（アダプタ実装）。Usecase が依存する抽象（`DocumentParser`, `DocumentRenderer`, `Storage`）を定義し、アダプタがそれを実装します。
- **Frameworks & Drivers（外側）**: `main.py`, `sample_main.py`, `mdformat`、実際のファイルシステムなど。ここでアダプタを組み立てて Usecase に注入します。

設計上の方針: ドメインは完全に副作用を排し、Usecase はドメインに依存するが外側の具象には依存しない。外側（アダプタ）は `src/interfaces` の抽象を実装して内側へ接続します。外部ライブラリ（例: `mdformat`）はアダプタ層でラップして差し替え可能にすることを推奨します。

### クリーンアーキテクチャ採用方針

本プロジェクトはクリーンアーキテクチャ（依存性の向き：外側→内側）への移行を推奨します。現状のコードベースは既にドメインの純粋性や `Protocol` による抽象化を備えており、移行のコストは低いと見込まれます。導入の目的は、ビジネスルール（ドメイン）を外部技術・フレームワークから独立させ、テスト容易性と差し替え性を高めることです。

移行の方針要点:

- **内側（Entities / Domain）**: `src/domain` に保持し副作用を排除する。ここに依存関係は集中する。
- **アプリケーション層（Usecase）**: `src/usecase` に配置し、ドメインを使ってユースケースを実装する。外部依存は `src/interfaces/protocols.py` の抽象を通じて扱う。
- **インターフェイス（Ports）**: `src/interfaces/protocols.py` を内側のポートとして扱い、Usecase がこれらの抽象に依存する。
- **アダプタ（Adapters / Gateways）**: `src/adapters` に配置し、`protocols` の実装を提供する。具体実装はここに閉じる。

この設計により、`usecase` 層は `adapters` に直接依存することなく、テスト時はモックやスタブを注入して外部 IO に依存しない単体テストが可能になります。

## モジュール責務

- `src/domain/doc_ir.py`:
	- `DocNode` 系（`Heading`, `Paragraph`, `BulletList`, `NumberedList`, `Table`, `Image`）と `Document` を定義。
	- `Table.as_dict` を持ち、表→辞書変換のロジックとバリデーションを提供。
- `src/domain/markdown_parser.py`:
	- `DocParser` ユーティリティを提供。`find_heading`, `first_heading`, `tables`, `bullet_list_after` を備える。
	- `MarkdownParseError` を定義。
- `src/adapters/markdown_parser.py`:
	- 文字列から `Document` を生成する具体パーサ。フロントマター検出、行走査による構文解析を行う。
- `src/adapters/markdown_renderer.py`:
	- `Document` から Markdown 文字列を生成する。レンダリングはノード毎に分岐して処理する。
- `src/adapters/markdown_adapter.py`:
	- `DocumentParser` / `DocumentRenderer` プロトコルに適合させるアダプタを提供。`MarkdownRendererAdapter` は `mdformat` を利用して出力を整形する。
- `src/adapters/file_storage.py`:
	- `Storage` プロトコルに従うファイル読み書き実装。

## データモデル詳細

- `Document`
	- `front_matter: dict[str,str]` — HTML コメント形式で取り出したキー/バリューの辞書
	- `nodes: list[DocNode]` — ドキュメント本文を示すノード列
- `Table`
	- `headers: list[str]`
	- `rows: list[list[str]]`
	- `as_dict(ignore_extra_columns: bool = False) -> dict[str,str]`:
		- 実装は行を順にスキャンし、`row[0]` をキー、`row[1]` を値として格納
		- `len(row) < 2` の場合 `ValueError`
		- `len(row) > 2` の場合は `ignore_extra_columns` が False なら `ValueError`、True なら余分な列を無視
		- 重複キー検出で `ValueError`

## 主要クラス・関数のシグネチャ

- `class DocConvertible(ABC)` (`src/domain/doc_convertible.py`)
	- `def to_nodes(self) -> list[DocNode]` — インスタンスをノード列に変換
	- `@classmethod def from_nodes(cls, nodes: list[DocNode]) -> T` — ノード列からインスタンスを生成
	- 設計制約: I/O や文字列整形は行わない
- `class DocParser` (`src/domain/markdown_parser.py`)
	- `def find_heading(self, level: int) -> list[Heading]`
	- `def first_heading(self, level: int) -> Heading | None`
	- `def tables(self) -> list[Table]`
	- `def bullet_list_after(self, heading_text: str, level: int) -> list[str]`
- `def parse_markdown(markdown_text: str) -> Document` (`src/adapters/markdown_parser.py`)
	- 主要処理: フロントマター抽出 → 行走査で各ノードを構築 → `Document(front_matter, nodes)` を返す
	- 例外: `MarkdownParseError`
- `def document_to_markdown(doc: Document) -> str` (`src/adapters/markdown_renderer.py`)
	- ノード毎のレンダリングをまとめて文字列を返す。整形は行わない（`MarkdownRendererAdapter` が `mdformat` を呼ぶ）。

## パース / レンダリングのフロー（シーケンス）

1. 呼び出し側が `FileStorage.read(path)` で Markdown 文字列を取得
2. `MarkdownParserAdapter.parse(text)` を呼び `Document` を得る
3. 必要に応じ `DocParser(nodes)` を生成し、`tables()` や `find_heading()` を使ってノードを検索
4. ユーザが実装した `DocConvertible.from_nodes(nodes)` を使ってアプリケーションモデルを生成
5. 逆変換は `to_nodes()` でノード列を得て `MarkdownRendererAdapter.render(doc)` に渡す
6. `FileStorage.write(path, content)` でファイルに保存

## アルゴリズムと実装ノート

- **フロントマター検出**: ファイル先頭で `<!--` を検出し、`-->` までの行を `key: value` で分割して辞書化。空行はスキップ。
- **見出し検出**: 行頭の `#` の数でレベルを決定し、その後のテキストを見出し文として取得。空の見出しは `MarkdownParseError` を投げる。
- **表のパース**:
	- ヘッダ行は `|` 区切りでセルを抽出（先頭・末尾の `|` を除去して `headers` とする）
	- 次行が `|---|` のようなセパレータ行（正規表現 `^\|[\s\-\|]*\|$`）であればスキップ
	- 以降 `|` で始まる行を `rows` として収集
- **表→辞書 (`Table.as_dict`) の注意**: 行ごとにセル数チェックを行い、例外を明示的に投げることで呼び出し側で明確に扱えるようにしている。

## エラー処理と例外設計

- `MarkdownParseError`: パース時の構文エラー。メッセージに行番号や原因を含める。
- `ValueError`: 内部データ検証（例: `Table.as_dict` の列数・重複キー）に使用。
- 例外ハンドリング方針: アダプタ/ユースケース層で捕捉してユーザ向けメッセージに変換、ログ記録を行う。

## 拡張性・入れ替えポイント

- 新しいノードを追加する場合:
	- `src/domain/doc_ir.py` にノードを追加し、`adapters` の `parse_markdown` と `render_node`（または `document_to_markdown`）を拡張する。
- ストレージの入れ替え:
	- `Storage` プロトコルを実装して `FileStorage` を差し替えればよい。
- カスタムフォーマット/拡張 Markdown を導入する場合:
	- `src/adapters/markdown_parser.py` のパーサをプラグイン化して差し替える設計を推奨。

## テスト戦略

- 単体テストの粒度:
	- `Document` / `Table.as_dict` の境界値テスト（列数不足、余分列、重複キー）
	- `parse_markdown` の機能テスト（フロントマター、見出し、各種ノード）
	- `document_to_markdown` の逆方向テスト（round-trip）
	- `DocParser` ユーティリティ（`find_heading`, `tables`, `bullet_list_after`）
- リポジトリ内の既存テストファイル例: `tests/test_domain_docparser.py`, `tests/test_table_as_dict.py`, `tests/test_document_usecases.py` を参照し、各ユースケースに対する網羅的テストを維持する。

## 変更履歴

- 2025-12-27: 初版（実装を参照して作成）

## ファイル・モジュールマッピング

- `src/domain`:
	- `doc_ir.py`: `Document` と `DocNode` 定義、`Table.as_dict` の実装
	- `doc_convertible.py`: `DocConvertible` 抽象クラス
	- `markdown_parser.py`: `DocParser` ユーティリティ（ノード検索など）
- `src/interfaces`:
	- `protocols.py`: `DocumentParser`, `DocumentRenderer`, `Storage` の抽象
- `src/adapters`:
	- `markdown_parser.py`: 文字列→`Document` 実装
	- `markdown_renderer.py`: `Document`→文字列 実装
	- `markdown_adapter.py`: `DocumentParser` / `DocumentRenderer` アダプタ（`mdformat` 整形）
	- `file_storage.py`: `Storage` のファイル実装
- `src/usecase`:
	- `convert_usecase.py`: `ConvertFileUsecase`（ユースケースの骨組み）
	- `document_usecases.py`: `dump_eval_item` / `load_eval_item` 等のユーティリティ
	- `eval_item.py`: `EvalItem`（`DocConvertible` 実装）

## Usecase 詳細: `ConvertFileUsecase`

- 目的: アダプタ（parser/renderer/storage）を注入し、ファイル ↔ ドメインオブジェクト の変換を提供する。
- 主要メソッド:
	- `__init__(self, parser: DocumentParser, renderer: DocumentRenderer, storage: Storage)`
	- `load_model_from_path(self, path: Path, model_cls: Type[DocConvertible]) -> DocConvertible`
		- 動作: `storage.read(path)` → `parser.parse(text)` → `model_cls.from_nodes(doc.nodes)`
		- 例外: パース失敗は `MarkdownParseError`、モデル変換失敗は `ValueError` を伝搬
	- `save_model_to_path(self, model: DocConvertible, path: Path) -> None`
		- 動作: `model.to_nodes()` → `Document(front_matter={}, nodes=nodes)` → `renderer.render(doc)` → `storage.write(path, text)`

## DI / 実行エントリの例

- `sample_main.py`（リポジトリ内）を参照。アダプタ実装を生成して Usecase に注入するサンプルコードを提供している。

## テストマッピング

- ドメイン層のテスト:
	- `tests/test_domain_docparser.py` — `DocParser` の振る舞い
	- `tests/test_table_as_dict.py` — `Table.as_dict` の境界テスト
- ユースケース/統合テスト:
	- `tests/test_document_usecases.py` — `dump_eval_item` / `load_eval_item` の round-trip
	- `tests/test_convert_usecase.py` — `ConvertFileUsecase` の単体テスト（in-memory ストレージ / ダミー実装）

## クリーンアーキテクチャ移行チェックリスト（実務向け）

1. `src/usecase` に代表的ユースケースを実装し、adapter は `protocols` の実装のみを提供する。
2. ユースケースのユニットテストは `protocols` をモックして実行できることを確認する。
3. ドメイン層から `adapters` を直接参照する箇所がないかをコードレビューでチェックする。
4. 重要な外部依存（例: `mdformat`）は `Formatter` のようなポートを定義してラップすることを検討する。


