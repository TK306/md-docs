# 内部設計仕様書

## 目次

- **アーキテクチャ概要**: 層構造と責務の切り分け
- **モジュール責務**: `src/domain`, `src/adapters`, `src/interfaces`, `src/usecase` の役割
- **データモデル詳細**: `Document` / `DocNode` 型、各フィールド、`Table.as_dict` の仕様
- **主要クラス・関数のシグネチャ**: 具体的な型と返り値、例外
- **パース/レンダリングのフロー**: シーケンス（ステップ毎の処理）
- **アルゴリズムと実装ノート**: 正規表現、表のパース、フロントマター処理
- **エラー処理と例外設計**: 例外タイプとハンドリング方針
- **拡張性・入れ替えポイント**: 新しいノード追加やストレージ交換の手順
- **テスト戦略**: 単体テストの粒度と代表的なテスト項目
- **変更履歴**

---

## アーキテクチャ概要

本プロジェクトはクリーンアーキテクチャ（Ports & Adapters / Onion / Hexagonal の考え方）を採用します。依存関係の基本ルールは「外側は内側に依存するが、内側は外側に依存しない（Dependency Rule）」です。これによりドメイン（ビジネスロジック）を外部技術やフレームワークから独立させ、保守性・テスト容易性・差し替え性を高めます。

主なレイヤ（内側 → 外側）:

- **Domain（最内側）**: `src/mddocs/domain` — 純粋なモデル（`Document`, `DocNode`, `DocConvertible`）と純粋関数/シリアライザ。
- **Usecase / Application**: `src/mddocs/usecase` — ドメインを組み合わせるユースケース（例: `ConvertFileUsecase`）。外部依存は `src/mddocs/interfaces` のプロトコル経由で受け取る。
- **Interface / Adapters**: `src/mddocs/interfaces`（プロトコル）と `src/mddocs/adapters`（具象実装）。外部 I/O と整形器（`mdformat` 等）をここで扱う。
- **Public API layer**: `src/mddocs/api` — 利便ヘルパやトップレベルで再エクスポートする公開 API の実装。利用者が日常的に参照するシンボルはこの層に置く。

設計方針（簡潔）:

- ドメインは副作用を持たない。文字列整形やファイル I/O はドメイン外で行う。
- ユースケースはドメインに依存するが、具象アダプタには依存しない（プロトコル注入）。
- `mddocs.api` は "公開面" の実装場所。トップレベル `mddocs` はここから主要シンボルを再エクスポートするのみとする。

## モジュール責務（簡潔マッピング）

- `src/mddocs/domain`:
	- `doc_ir.py`: `DocNode` 型群と `Document`、`Table.as_dict` の実装。
	- `doc_convertible.py`: `DocConvertible` 抽象（`to_nodes`, `from_nodes`/`from_cursor`, `to_front_matter` フック）。
	- `doc_cursor.py`: `NodeCursor`（ノード巡回ユーティリティ）と関連エラー定義。

- `src/mddocs/interfaces`:
	- `protocols.py`: `DocumentParser`, `DocumentRenderer`, `Storage` などの型・契約を定義。

- `src/mddocs/adapters`:
	- `markdown_parser.py`: 文字列→`Document` の具象パーサ（フロントマター検出、テーブル解析等）。
	- `markdown_renderer.py`: `Document`→Markdown テキストのレンダラ（ノード毎の変換ロジック）。
	- `markdown_adapter.py`: `DocumentParser`/`DocumentRenderer` をラップするアダプタ。
	- `file_storage.py`: `Storage` のファイル実装。

- `src/mddocs/api`:
	- `__init__.py`: `dump_markdown` 等の公開ヘルパ。
	- `nodes.py`: `Table` 等の再エクスポート（利用者向け）。

- `src/mddocs/usecase`:
	- `convert_usecase.py`: `ConvertFileUsecase`（文字列読み書き→モデル変換のユースケース）。

（注）上記は実装ファイルの所在を示すもので、外部 API の公開対象は `mddocs.api` に限定している点に注意してください。

## データモデル詳細

（`Document`, `DocNode`, `Table` の詳細は既存記述を維持。実装上の注意点や例外仕様はこの章で明記します。具体的な正規表現や行スキャンの細部は `src/mddocs/adapters/markdown_parser.py` の実装ノートで管理します。）

## パース / レンダリングのフロー

（既存のステップを踏襲。ユースケースは `Document.front_matter` を `from_nodes(..., front_matter=...)` に渡すことを保証します。）

## 実装ノート（抜粋）

- フロントマターの抽出はファイル先頭で `<!--` を検出し `-->` までを処理する。空行や不正フォーマットは明示的に `MarkdownParseError` を返す。
- テーブルは `|` 区切りでパースし、区切り行（`|---|` など）を認識してヘッダ/行を区分する。行長や重複キーの検査は `Table.as_dict` 側で行う。
	- ヘッダと行の列数整合ルール（追記）:
		- 仕様としてはテーブルのヘッダセル数と各データ行のセル数が一致することを推奨します。
		- 現状の実装はヘッダ長と行長の一致を厳密に強制していません。必要に応じて `Table` に行長検証メソッドを追加し、厳格モードで不整合時に `ValueError` を投げることを検討してください。

## テスト戦略

仕様トレーサビリティと運用の簡素化のため、仕様対応テストは `tests/spec` ディレクトリに集約します。各テストファイル名は少なくとも 1 つの `SPEC-` ID を含む命名にし、どの仕様を検証しているかがファイル名から把握できるようにします。

運用ルール:

- **配置**: 仕様準拠テストは `tests/spec/` に配置する（回帰確認のプライマリセット）。通常のユニットテストは `tests/` のルートに置く。
- **命名規則**: ファイル名は `test_spec_<spec-id>_<short-description>.py` 形式を推奨（例: `test_spec_fm_002_front_matter_propagation.py`）。複数の SPEC をカバーする場合は主要な SPEC を優先して付与するか、必要に応じて複数 ID を連結する（`test_spec_table_001_002_...` のように）。
- **テスト粒度**: 各テスト関数は原則として単一の `SPEC-` ID を検証すること。複数の関連仕様を同時に検証する必要があるケースでは、ファイルレベルで複数の SPEC をカバーしてよい。
- **トレーサビリティ**: 各テストファイルの先頭にコメントで `Covered SPECs: ...` を記載し、外部設計書上のどの項目を検証しているかを明示する。
- **実行方針**: CI ではまず `tests/spec/` を実行して仕様回帰を確認し、そのあとに残りのユニットテストを走らせるワークフローを推奨する。

これにより、テストと仕様の対応関係が明確になり、仕様変更時に更新すべきテストを素早く特定できます。

### Spec と Unit の分離方針

- **目的**: `tests/spec/` は外部設計（ユーザや他システムから見た振る舞い）に対する回帰検証に集中します。内部実装の細かい挙動やユーティリティ関数の単体検査は `tests/unit/` に置き、開発者向けの詳細検証を行います。
- **境界例**:
	- `ConvertFileUsecase`, `dump_markdown`, `FileStorage` など「外部から利用される API」は `tests/spec/` で検証します。
	- `Table.as_dict`, `NodeCursor` の細かい境界条件、パーサの内部ユーティリティの厳密な例外ハンドリングなどは `tests/unit/` に置きます。
- **命名と配置**:
	- `tests/spec/` のファイル名は `test_spec_<spec-id>_<short>.py` を推奨。
	- `tests/unit/` のファイル名は `test_<module>_<case>.py` を推奨。
- **CI 実行順**: CI ではまず `tests/spec/` を実行して仕様回帰を確認し、その後 `tests/unit/` を実行して内部の回帰を確認するワークフローを推奨します。

この分離により、仕様変更時にまず `tests/spec/` を見れば影響範囲が把握でき、内部実装の詳細は `tests/unit/` で扱えるようになります。

## 主要クラス・関数のシグネチャ

- `class DocConvertible(ABC)` (`src/domain/doc_convertible.py`)
	- `def to_nodes(self) -> list[DocNode]` — インスタンスをノード列に変換
	- `@classmethod def from_nodes(cls, nodes: list[DocNode], front_matter: dict[str,str] | None = None) -> T`
		- 既定挙動: 具象クラスが `from_cursor(cls, cur)` を実装している場合、`from_nodes` の既定実装は `NodeCursor(nodes, front_matter)` を作成して `from_cursor` を呼び出す。これにより具象クラスは `NodeCursor` を使って簡潔にノード抽出処理を実装できる。
		- 互換性: 旧来の `from_nodes` を直接オーバーライドする実装はそのまま動作する。
	- 設計制約: I/O や文字列整形は行わない。変換ロジックとバリデーションは具象クラス側で行う。
	- フロントマター出力フック: `DocConvertible` は `to_front_matter(self) -> dict[str,str]` を提供することが推奨されます。既定実装は空辞書を返します。`ConvertFileUsecase.save_model_to_path` はこのフロントマターを利用して `Document(front_matter=...)` を作成します。

- `class DocumentInspector` (`src/domain/markdown_parser.py`)
	- `def find_heading(self, level: int) -> list[Heading]`
	- `def first_heading(self, level: int) -> Heading | None`
	- `def tables(self) -> list[Table]`
	- `def bullet_list_after(self, heading_text: str, level: int) -> list[str]`
- `def parse_markdown(markdown_text: str) -> Document` (`src/adapters/markdown_parser.py`)
	- 主要処理: フロントマター抽出 → 行走査で各ノードを構築 → `Document(front_matter, nodes)` を返す
	- 例外: `MarkdownParseError`
- `def document_to_markdown(doc: Document) -> str` (`src/adapters/markdown_renderer.py`)
	- ノード毎のレンダリングをまとめて文字列を返す。整形は行わない（`MarkdownRendererAdapter` が `mdformat` を呼ぶ）。

## パース / レンダリングのフロー（シーケンス）

1. 呼び出し側が `FileStorage.read(path)` で Markdown 文字列を取得
2. `MarkdownParserAdapter.parse(text)` を呼び `Document` を得る
3. 必要に応じ `DocumentInspector(nodes)` を生成し、`tables()` や `find_heading()` を使ってノードを検索
4. ユーザが実装した `DocConvertible.from_nodes(nodes, front_matter)` または `from_cursor(cur)` を使ってアプリケーションモデルを生成
	- パーサは `Document(front_matter, nodes)` を返すため、`front_matter` を `from_nodes` に渡すことでモデル生成に利用できる。
	- 具象クラスが `from_cursor` を実装している場合、`from_nodes` の既定実装が `NodeCursor(nodes, front_matter)` を生成して `from_cursor` を呼び出すため、具象は `NodeCursor` を直接扱うことで実装が簡潔になる。
5. 逆変換は `to_nodes()` でノード列を得て `MarkdownRendererAdapter.render(doc)` に渡す
6. `FileStorage.write(path, content)` でファイルに保存

## アルゴリズムと実装ノート

- **フロントマター検出**: ファイル先頭で `<!--` を検出し、`-->` までの行を `key: value` で分割して辞書化。空行はスキップ。
- **見出し検出**: 行頭の `#` の数でレベルを決定し、その後のテキストを見出し文として取得。空の見出しは `MarkdownParseError` を投げる。
- **表のパース**:
	- ヘッダ行は `|` 区切りでセルを抽出（先頭・末尾の `|` を除去して `headers` とする）
	- 次行が `|---|` のようなセパレータ行（正規表現 `^\|[\s\-\|]*\|$`）であればスキップ
	- 以降 `|` で始まる行を `rows` として収集
- **表→辞書 (`Table.as_dict`) の注意**: 行ごとにセル数チェックを行い、例外を明示的に投げることで呼び出し側で明確に扱えるようにしている。

## エラー処理と例外設計

- `MarkdownParseError`: パース時の構文エラー。メッセージに行番号や原因を含める。
- `ValueError`: 内部データ検証（例: `Table.as_dict` の列数・重複キー）に使用。
- 例外ハンドリング方針: アダプタ/ユースケース層で捕捉してユーザ向けメッセージに変換、ログ記録を行う。

## 拡張性・入れ替えポイント

- 新しいノードを追加する場合:
	- `src/domain/doc_ir.py` にノードを追加し、`adapters` の `parse_markdown` と `render_node`（または `document_to_markdown`）を拡張する。
- ストレージの入れ替え:
	- `Storage` プロトコルを実装して `FileStorage` を差し替えればよい。
- カスタムフォーマット/拡張 Markdown を導入する場合:
	- `src/adapters/markdown_parser.py` のパーサをプラグイン化して差し替える設計を推奨。

## テスト戦略

本プロジェクトでは外部設計で定義した仕様（`docs/02_外部設計仕様書.md` の `SPEC-...`）と実装テストを一対一で紐付けします。各仕様項目は専用のテスト（ファイル+関数）で検証し、仕様の回帰を容易に追跡できるようにします。

方針:

- **単一責務のテスト**: 各テストは 1 つの `SPEC-` ID に対応し、その仕様の期待動作とエラー条件を検証する。
- **外部依存の分離**: Usecase 層のテストは `protocols` をモック/スタブして外部 I/O に依存しない単体テストを行う。
- **仕様トレーサビリティ**: ドキュメントに SPEC ID とテスト名を明記し、仕様変更時にどのテストを更新すべきか一目で分かるようにする。

追加ルール:

- 新しい外部仕様を追加する際は必ず `SPEC-` プレフィックスで ID を割り振り、対応するテストを `tests/spec_tests/` に作成すること。
- 既存テスト（リポジトリ内）とは別に、仕様トレーサビリティ用の `tests/spec_tests/` を優先して回帰検証を実行する運用を推奨します。


## 変更履歴

- 2025-12-27: 初版（実装を参照して作成）

## ファイル・モジュールマッピング

- `src/domain`:
	- `doc_ir.py`: `Document` と `DocNode` 定義、`Table.as_dict` の実装
	- `doc_convertible.py`: `DocConvertible` 抽象クラス
	- `markdown_parser.py`: `DocumentInspector`（旧 `DocParser`）ユーティリティ（ノード検索など）
	- `doc_cursor.py`: `NodeCursor`（旧 `DocCursor`） — `DocNode` 列を逐次巡回するユーティリティで、具象の `from_cursor` 実装を容易にする。
- `src/interfaces`:
	- `protocols.py`: `DocumentParser`, `DocumentRenderer`, `Storage` の抽象
- `src/adapters`:
	- `markdown_parser.py`: 文字列→`Document` 実装
	- `markdown_renderer.py`: `Document`→文字列 実装
	- `markdown_adapter.py`: `DocumentParser` / `DocumentRenderer` アダプタ（`mdformat` 整形）
	- `file_storage.py`: `Storage` のファイル実装
- `src/usecase`:
	- `convert_usecase.py`: `ConvertFileUsecase`（ユースケースの骨組み）

## Usecase 詳細: `ConvertFileUsecase`

- 目的: アダプタ（parser/renderer/storage）を注入し、ファイル ↔ ドメインオブジェクト の変換を提供する。
- 主要メソッド:
	- `__init__(self, parser: DocumentParser, renderer: DocumentRenderer, storage: Storage)`
	- `load_model_from_path(self, path: Path, model_cls: Type[DocConvertible]) -> DocConvertible`
		- 動作: `storage.read(path)` → `parser.parse(text)` → `model_cls.from_nodes(doc.nodes, front_matter=doc.front_matter)`
		- 例外: パース失敗は `MarkdownParseError`、モデル変換失敗は `ValueError` を伝搬
	- `save_model_to_path(self, model: DocConvertible, path: Path) -> None`
		- 動作: `model.to_nodes()` を呼びノード列を取得。モデルが `to_front_matter()` を実装していればその戻り値を用いて `Document(front_matter=...)` を作成し、`renderer.render(doc)` の結果を `storage.write(path, text)` で保存する（未実装なら空辞書を用いる）。

## DI / 実行エントリの例

- `sample_main.py`（リポジトリ内）を参照。アダプタ実装を生成して Usecase に注入するサンプルコードを提供している。

## クリーンアーキテクチャ移行チェックリスト（実務向け）

1. `src/usecase` に代表的ユースケースを実装し、adapter は `protocols` の実装のみを提供する。
2. ユースケースのユニットテストは `protocols` をモックして実行できることを確認する。
3. ドメイン層から `adapters` を直接参照する箇所がないかをコードレビューでチェックする。
4. 重要な外部依存（例: `mdformat`）は `Formatter` のようなポートを定義してラップすることを検討する。


